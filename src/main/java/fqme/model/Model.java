package fqme.model;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import fqme.column.Column;
import fqme.column.common.NumericColumn;
import fqme.connection.DBConfig;
import lombok.Getter;

/**
 * ORM model realization.
 */
public abstract class Model<T extends Model<T>> {
    /**
     * Autogenerated id.
     */
    @Getter
    private Optional<Integer> id = Optional.empty();
    public static final NumericColumn<Integer> id_ = new NumericColumn<>("id");

    /**
     * Map with meta info (table names, fields, etc.)
     * for Model subclasses.
     */
    private static HashMap<Class<? extends Model<?>>, ModelMetaInfo> modelsMetaInfo = new HashMap<>();

    /**
     * Build and store model subclass meta info.
     *
     * @param modelClass model subclass
     * @param configPath path to config file
     */
    public static void register(Class<? extends Model<?>> modelClass, DBConfig dbConfig)
            throws NoSuchFieldException, IllegalAccessException {
        // generate table name from class name
        String tableName = modelClass.getSimpleName().replaceFirst("Model$", "").toLowerCase();

        Field[] classFields = modelClass.getDeclaredFields();
        List<String> columnsNames = new ArrayList<>();

        // HashMap<String, Class<?>> fieldsTypes = new HashMap<>();
        List<Class<?>> fieldsTypesList = new ArrayList<>();
        Map<String, Field> fields = new HashMap<>();
        for (Field field : classFields) {
            if (Column.class.isAssignableFrom(field.getType())) {
                Column<?> column = (Column<?>) field.get(null);
                // add name of Column
                columnsNames.add(column.getName());

                // add type of field
                Class<?> fieldType = modelClass.getDeclaredField(column.getName()).getType();
                fieldsTypesList.add(fieldType);

                // add field to dataFields
                fields.put(column.getName(), field);
            }
        }
        Class<?>[] fieldsTypes = new Class<?>[fieldsTypesList.size()];
        for (int i = 0; i < fieldsTypesList.size(); i++) {
            fieldsTypes[i] = fieldsTypesList.get(i);
        }
        // store model subclass meta info
        ModelMetaInfo metaInfo = new ModelMetaInfo(tableName, columnsNames, fieldsTypes, fields, dbConfig);
        modelsMetaInfo.put(modelClass, metaInfo);
    }

    /**
     * Get model subclass meta info.
     *
     * @param modelClass model subclass
     * @return model subclass meta info
     */
    public static ModelMetaInfo getModelMetaInfo(Class<? extends Model<?>> modelClass) {
        return Model.modelsMetaInfo.get(modelClass);
    }

    /**
     * Initialize model from objects array with values of fields in proper order.
     * Use for instantiating from ResultSet
     *
     * @see View
     *
     * @param objects    Array of fields values
     * @param modelClass subclass of Model
     * @return Model instance
     */
    public static <K extends Model<K>> K fromFieldsValues(Object[] objects, Class<K> modelClass) throws Exception {
        ModelMetaInfo metaInfo = Model.getModelMetaInfo(modelClass);
        Constructor<K> constructor = modelClass.getConstructor(metaInfo.getFieldsTypes());
        return constructor.newInstance(objects);
    }
}
