package fqme.model;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import fqme.column.Column;
import fqme.column.common.NumericColumn;
import fqme.connection.DBConfig;
import lombok.Getter;

/**
 * ORM model realization.
 */
public abstract class Model<T extends Model<T>> {
    /**
     * Autogenerated id.
     */
    @Getter
    private Optional<Integer> id = Optional.empty();
    public static final NumericColumn<Integer> id_ = new NumericColumn<>("id");

    /**
     * Map with meta info (table names, fields, etc.)
     * for Model subclasses.
     */
    private static HashMap<Class<? extends Model<?>>, ModelMetaInfo> modelsMetaInfo = new HashMap<>();

    /**
     * Build and store model subclass meta info.
     *
     * @param modelClass model subclass
     * @param configPath path to config file
     */
    public static void register(Class<? extends Model<?>> modelClass, DBConfig dbConfig) throws NoSuchFieldException, IllegalAccessException {
        // generate table name from class name
        String tableName = modelClass.getSimpleName().replaceFirst("Model$", "").toLowerCase();

        Field[] classFields = modelClass.getDeclaredFields();
        List<String> columnsNames = new ArrayList<>();

        // HashMap<String, Class<?>> fieldsTypes = new HashMap<>();
        List<Class<?>> fieldsTypes = new ArrayList<>();
        Map<String, Field> fields = new HashMap<>();
        for (Field field : classFields) {
            if (Column.class.isAssignableFrom(field.getType())) {
                Column<?> column = (Column<?>) field.get(null);
                // add name of Column
                columnsNames.add(column.getName());

                // add type of field
                Class<?> fieldType = modelClass.getDeclaredField(column.getName()).getType();
                fieldsTypes.add(fieldType);

                // add field to dataFields
                fields.put(column.getName(), field);
            }
        }

        // store model subclass meta info
        ModelMetaInfo metaInfo = new ModelMetaInfo(tableName, columnsNames, fieldsTypes, fields, dbConfig);
        modelsMetaInfo.put(modelClass, metaInfo);
    }

    /**
     * Get model subclass meta info.
     *
     * @param modelClass model subclass
     * @return model subclass meta info
     */
    public static ModelMetaInfo getModelMetaInfo(Class<? extends Model<?>> modelClass) {
        return Model.modelsMetaInfo.get(modelClass);
    }

    /**
     * Initialize model from ResultSet.
     */
    public static <K extends Model<K>> K fromResultSet(ResultSet resultSet, Class<K> modelClass) throws Exception {
        ModelMetaInfo metaInfo = Model.getModelMetaInfo(modelClass);

        Class<?>[] fieldsTypes = new Class<?>[metaInfo.getFieldsTypes().size()];
        for (int i = 0; i < metaInfo.getFieldsTypes().size(); i++) {
            fieldsTypes[i] = metaInfo.getFieldsTypes().get(i);
        }
        Constructor<K> constructor = modelClass.getConstructor(fieldsTypes);

        Object[] fieldsValues = new Object[metaInfo.getFieldsTypes().size()];
        for (int i = 0; i < metaInfo.getFieldsTypes().size(); i++) {
            String columnName = metaInfo.getColumnsNames().get(i);
            fieldsValues[i] = resultSet.getObject(columnName);
        }

        return constructor.newInstance(fieldsValues);
    }
}
